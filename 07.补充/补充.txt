1.hash/history

2.
call()、apply()、bind()等方法不能改变箭头函数中的this指向 

3.
闭包作用：
局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。

4.Set 和 Map有什么区别？
    -set 与 map 
        一个是键值对(类似对象),一个是集合(类似数组)

    -map 和 object
        Map和Object的区别
            键的顺序:Map中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
            键个数:Map的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
            键类型:Map的键可以是任意值，包括函数、对象或任意基本类型。	Object 的键必须是 String 或是Symbol。
            性能:在频繁增删键值对的场景下表现更好。	在频繁添加和删除键值对的场景下未作出优化。

5.Rem你是怎么做适配的

6.怎么解决白屏问题/首屏加载
    路由懒加载
    cdn 很多时候我们在main.js中直接import一些ui库或者css文件啥的，以后可以在index.html，通过script外链引入，这样就不会通过我们的webpack打包
    loading效果
    按需引入
    
7.说一下slice splice split 的区别


8.说一下怎么把类数组转换为数组?

9.vue3

10.SPA单页面有什么优缺点
    优点：
    体验好，不刷新，减少 请求  数据ajax异步获取 页面流程；
    前后端分离
    减轻服务端压力
    共用一套后端程序代码，适配多端

    缺点：
    首屏加载过慢；
    SEO 不利于搜索引擎抓取

11.dns
    https://juejin.cn/post/6844904054074654728
    DNS就是一个键值对的列表。
    在客户端输入 URL 后，会有一个[递归查找]的过程，
    从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。
    如果本地DNS服务器无法查询到，则[迭代查找]
    根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址->
    顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址->
    权威 DNS 服务器 ：返回相应主机的 IP 地址



    ; - hosts 
    ;     Hosts是一个系统文件，其基本作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，
    ;     当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，
    ;     一旦找到，系统会立即打开对应网页，如果没有找到，则系统再会将网址提交DNS域名解析服务器进行IP地址的解析
    ;     比如,localhost是一个域名，127.0.0.1为IP地址

    ; - DNS缓存
    ;     如果hosts文件没有的话，那么DNS就会查看本地的DNS缓存

    ; - DNS服务器缓存
    ;     如果是第一次访问某个域名的话，那本地缓存肯定是没有的。
    ;     DNS服务器首先是查看自己的缓存，如果有的话，就可以直接返回

    ; - DNS服务器递归查找
    ;     如果DNS服务器也没有缓存的话，那就要进行递归查找了。
    
    根 DNS 服务器
    首先我们要明确根域名是什么，比如 www.baidu.com，有些同学可能会误以为 com 就是根域名，其实 com 是顶级域名，www.baidu.com 的完整写法是 www.baidu.com.，最后的这个 . 就是根域名。
    根 DNS 服务器的作用是什么呢？就是管理它的下一级，也就是顶级域 DNS 服务器。通过询问根 DNS 服务器，我们可以知道一个主机名对应的顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。

    顶级域 DNS 服务器
    除了前面提到的 com 是顶级域名，常见的顶级域名还有 cn、org、edu 等。顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址。

    权威 DNS 服务器
    权威 DNS 服务器可以返回主机 - IP 的最终映射。
    关于这几个层次的服务器之间是怎么交互的，接下来我们会讲到 DNS 具体的查询过程，结合查询过程，大家就不难理解它们之间的关系了。



12.输入url发生了什么
    DNS
    三次握手
    http请求 (有缓存就用,强,或者协商)
    服务器接收,并发送http响应
    浏览器渲染
    四次挥手

13.vue性能优化 与 前端优化 
    按需引入
    CDN 
    图片懒加载
    路由懒加载
    事件委托
    防抖节流

    减少重排重绘
    字体图标 iconfont 代替图片图标
    适当采用 keep-alive 缓存组件

14.样式绑定

15.BFC
    - 通俗来讲：
        BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。           
    - 创建BFC的条件：
        元素设置浮动：float 除 none 以外的值；
        绝对定位元素（position 为 absolute 或 fixed ）。
        行内块元素，即 display 为 inline-block/flex
        overflow 的值不为 visible 。
    - BFC的规则 
        块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。BFC 是独立的容器，容器内部元素不会影响外部元素。
        相邻的两个容器的 margin  会重叠，创建新的 BFC 可以避免外边距重叠。
        计算 BFC 的高度时，需要计算浮动元素的高度。
        BFC 区域不会与浮动的容器发生重叠。
        每个元素的左 margin  值和容器的左 border  相接触。
    - BFC 具有一些特性 以及 可以解决的问题
        见掘金
        利用 2 ，我们可以避免 margin  合并问题。
        (可以看到上面我们为两个盒子的margin外边距设置的是10px，可结果显示两个盒子之间只有10px的距离，
        这就导致了margin塌陷问题，这时margin边距的结果为最大值，而不是合，为了解决此问题可以使用BFC规则
        或者简单粗暴方法一个设置margin，一个设置padding。)
        利用 3 ，我们可以避免高度塌陷。
        利用 4  和 5，我们可以实现三栏（或两栏）自适应布局。
    - margin塌陷
        子元素设置了margin-top距离顶部50px，按道理它会距离父元素顶部50px才对。但却是父元素离顶部50px
        一句话总结：父子嵌套的元素垂直方向的margin取最大值。
        给父元素设置BFC
    - margin合并
        解决margin合并是给某个子元素添加父元素 然后给这个新增的父元素触发bfc
        子元素就会距离父元素顶部一段marigin
        父元素又会距离另一个子元素一段margin

16.FLEX
    - 概念
        FLEX提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。
        在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。
        弹性盒布局并没有这样内在的方向限制 
        存在两根轴,主轴和辅轴

    - 了解flex
        display:flex 

        flex-direction:row(reverse),column(reverse)
        flex-wrap:默认norwarp,warp(reverse)
        flex-flow:是flex-direction属性和flex-wrap属性的简写形式
        justify-content 属性定义了项目在主轴上的对齐方式
                        flex-start/end,center
                        space-between：项目均匀分布，第一项在启点线，最后一项在终点线
                        space-around：项目均匀分布，每一个项目两侧有相同的留白空间，相邻项目之间的距离是两个项目之间留白的和
                        space-evenly：项目均匀分布，所有项目之间及项目与边框之间距离相等
        align-content(多行有效) 属性定义了多根轴线的对齐方式。如果项目只有一根轴线(主轴只有一行)，该属性不起作用。
                        flex-start/end,center
                        stretch
                        space-between
                        space-around
        align-items(一行有效) 属性定义项目在交叉轴上如何对齐
                        flex-start/end,center
                        stretch方向拉伸显示
                        baseline交叉轴方向按第一行文字基线对齐

        flex-grow/flex-shrink 可以为0 1 2 3... 元素按比例增缩,缩小时还会参考元素大小,增大不会
        flex-basis 属性定义项目在分配额外空间之前的尺寸,它的默认值为auto，即项目的本来大小。
        flex属性是flex-grow, flex-shrink 和flex-basis的简写，默认值为0 1 auto。
        align-self 定义项目的对齐方式，可覆盖align-items属性
        order 可以控制项目在容器中的先后顺序。

    - 为什么要使用flex布局
        更好用,比如垂直居中,两栏布局

17.数据结构/排序
    O(1) ：常数级别，无论输入多大，它执行的步数都是恒定的，不会因为输入变大而变大，哈希表的查找就是这个级别。
    O(N) ：线性级别，随着输入变大耗费的步数也正向相关，遍历算法就是这个级别。
    O(logN) ：对数级别，输入每变大一倍，耗费步骤则增加1，二分查找算法属于这个级别。
    O(N²) ：平方级别，随着输入的变大所耗费的步数会成倍增加，一般当你的算法使用双层for循环就是这个级别，比如冒泡排序。


    17.1.数组和链表的区别
        数组 ，它在内存中是一块连续的内存地址。
        链表的元素内存地址可以是不连续的 ，它通过地址引用的方式指向下一个元素的位置
        队列 是一个先入先出的数据结构，它在数据结构上可以使用数组或者链表去实现
        栈 ，是一种先入后出/后入先出的数据结构

        区别
        数组：下标查找快，插入和删除慢。连续
        链表：头尾插入和删除快，查找慢。不一定连续

18.项目结构/src

19.require/import
    导入require 导出 exports/module.exports 是 CommonJS 的标准，通常适用范围如 Node.js
    import/export 是 ES6 的标准


20.css3
    Transition,Transform和Animation
    FLEX
    box-sizing
    rgba
    三个边框属性，分别是border-radius、box-shadow和border-image


21.响应式布局
    https://juejin.cn/post/6844903814332432397
    响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局
    1.媒体查询
        根据不同分辨率定义不同的样式
        依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式
    2.百分比
        子元素的height或width中使用百分比，相对于子元素的直接父元素的width，height
        子元素的padding/margin如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width,与父元素的height无关
        子元素的top和bottom如果设置百分比，相对于直接非static定位(默认定位)的父元素的height
        子元素的left和right如果设置百分比，相对于直接非static定位(默认定位的)父元素的width
        由于不同属性依据的父元素不同,使布局问题变得复杂
    3.rem布局
        如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）
        具体代码是,给窗口加上一个事件监听,改变大小时,触发回调函数
        获取页面宽度,将font-size设置为页面的1/10,rem就会随之改动
        1rem是1/10,计算一个元素的rem时,用它的宽度除以设计稿宽度*10rem(即占10rem的百分比)就能得到
    4.视口单位
        使用vw作为css单位
        1px = 100vm/设备独立像素宽度

22.http/https
    22.1.HTTP是什么
        通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则

    22.2.发送HTTP大体流程
        1、客户端在应用层发出一个HTTP请求；
        2、为了传输方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层；
        3、在网络层（IP协议，Internet Protocol），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了；
        4、接收端的服务器在链路层收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。

    22.3.HTTP 的特点和缺点
        特点
        无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
        无状态：就是说每次HTTP请求都是独立的，请求结束不会记录连接的任何信息(提起裤子就不认人的意思)，减少了网络开销
                任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。
        灵活：通过http协议中头部的Content-Type标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
        简单快速：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，
                正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快

        缺点 
        无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，
                意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大
        明文传输：报文(header部分)使用的是明文，直接将信息暴露给了外界，WIFI陷阱就是复用明文传输的特点，
                诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
        队头阻塞：开启长连接(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，
                那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)

    22.4.组成/状态码/方法   
        304 Not Modified: 当协商缓存命中时会返回这个状态码。详见浏览器缓存

    22.5.url 
        协议 域名 端口 路径 参数 锚点
        URI 编码:URI 只能使用ASCII, ASCII 之外的字符是不支持显示的
                因此将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
                如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。

    22.6.什么是持久连接/长连接
        http1.0 每个请求/应答客户与服务器都要新建一个连接
        http1.1 请求头添加Connection: Keep-Alive 建立一个TCP连接后使客户端到服务端的连接持续有效，可以发送/接受多个http请求/响应
        看图

        - 优点
            减少了后续请求的响应时间，因为不需要等待建立TCP、握手、挥手、关闭TCP的过程
            减少CPU及内存的使用，因为不需要经常建立和关闭连接
        - 缺点
            一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数
            还有就是可能造成队头堵塞(下面有讲)，造成信息延迟

    22.7.什么是管线化(管道化)
        在http1.1中
        不使用管道化 请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3
        使用管道化 请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3(其实交叉也行,响应1在请求1后就可以了,看https://juejin.cn/post/6844903853985366023)

        管线化是在同一个TCP连接里发一个请求后不必等其回来就可以继续发请求出去，这可以减少整体的响应时间，
        管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。
        那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。就产生一个著名的问题队头堵塞

    22.8.如何解决 HTTP 的队头阻塞问题
        开启长连接时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态

        - 并发连接
            因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。
            一个域名最多可以并发6~8个，那咱就多来几个域名
        - 域名分片
            一个域名最多可以并发6~8个，那咱就多来几个域名
            比如a.baidu.com，b.baidu.com，c.baidu.com，多准备几个二级域名，当我们访问baidu.com时，
            可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了

    22.9.说一下 HTTP 代理
        HTTP有两种代理
        - 普通代理(中间人代理)
            代理服务器相当于一个中间人，一直帮两边传递东西
            看图,请求响应TCP都建立在他们之间
        - 隧道代理

    22.10.HTTP缓存及缓存代理(也叫浏览器缓存)
        https://juejin.cn/post/6993358764481085453#heading-2
        就是将http请求获取的页面资源存储在本地，之后再加载直接从缓存中获取而不用请求服务器，从而响应更快。

        - 强缓存
            第一次请求时，服务器把资源的过期时间通过响应头中的Expires和Cache-Control两个字段告诉浏览器，
            之后再请求这个资源的话，会判断有没有过期，没有过期就直接拿来用，不向服务器发起请求，这就是强缓存

            Expires 用来指定资源到期[绝对时间]，服务器响应时，添加在响应头中,如expires: Wed, 22 Nov 2021 08:41:00 GMT
            Cache-Control 指定资源过期[时间秒]，如下，表示在这个请求正确返回后的300秒内，资源可以使用，否则过期,如cache-control:max-age=300

            为什么指定缓存过期时间需要两个字段呢
            有的浏览器只认识 Cache-Control，有的浏览器不认识，不认识的情况下再找 Expires

            缺点
            就是缓存过期之后，不管资源有没有变化，都会重新发起请求，重新获取资源
            而我们希望的是在资源文件没有更新的情况下，即使过期了也不重新获取资源，继续使用旧资源
            所以协商缓存它来了，在强缓存过期的情况下，再走协商缓存的流程，判断文件有没有更新,如果没更新,即使强缓存过期了,也可以使用

        - 协商缓存
            第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，
            还会在响应头添加 Last-Modified 字段，告诉浏览器该资源的最后修改时间

            然后浏览器再次请求的时候就[把这个时间](也就是浏览器告诉服务器,你上次发给我的Last-Modified是什么)
            再通过另一个字段If-Modified-Since，发送给服务器,注意这个是请求头里的

            服务器把这两个字段的时间对比，如果是一样的，就说明文件没有被更新过
            ，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用即可；
            如果对比不一样说明资源有更新，就返回状态码200和新的资源


            -----但是Last-Modified/If-Modified-Since有缺陷-----
                如果资源有周期性变化，如资源修改后，在一个周期内又改回了原来的样子，我们认为这个周期前的缓存是可以使用的，但是Last-Modified不这样认为
                以及,因为Last-Modified只能以秒计时，如果在不可感知的时间内修改了文件，服务器端会认为没修改
            -------所以便有了另外一对 ETag/If-None-Match-------


            第一次请求资源时，服务器除了会在响应头上返回Expires、Cache-Control、Last-Modified，还返回Etag字段，
            表示当前资源文件的一个唯一标识。这个标识符由服务器基于文件内容编码生成，
            能精准感知文件的变化，只要文件内容不同，ETag就会重新生成

            然后浏览器再次请求的时候就把这个文件标识 再通过另一个字段 If-None-Match，发送给服务器[注意,这是请求头的]

            服务器再把收到的If-None-Match,和文件新生成的Etag对比，
            如果发现是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用；
            如果对比不一样说明资源有更新，就返回状态码200和新的资源

    22.11.HTTPS
        https://juejin.cn/post/6844904127420432391
        HTTP 有着一个致命的缺陷，那就是内容是明文传输的，没有经过任何加密，
        而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露

        HTTPS 是超文本传输安全协议，即HTTP + SSL/TLS。说白了，就是一个加强版的HTTP

        - SSL/TLS
            TLS是SSL的升级版

            - 对称加密
                双方用同样的加密规则,就是加密和解密使用同一个密钥
                问题:第三方知道加密规则(密钥)后,就很容易被破解
            - 非对称加密
                就是一对密钥，有公钥和私钥，其中一个密钥加密后的数据，只能让另一个密钥进行解密
                具体:服务端拥有一对私钥和公钥,告诉客户端公钥
                    客户端用公钥加密后,公钥反而无法解开这段数据,只能通过服务端的私钥解密

            - TLS使用的加密方式
                两种都有,详见完整的过程

            - 证书
                它是保存在源服务器的数据文件,由第三方颁布
                它可以帮我们验证服务器身份。因为如果没有验证的话，就可能被中间人劫持，
                假如请求被中间人截获，中间人把他自己的公钥给了客户端，客户端收到公钥就把信息发给中间人了，
                中间人解密拿到数据后，再请求实际服务器，拿到服务器公钥，再把信息发给服务器

            - 完整的过程(TLS握手过程)
                https://www.bilibili.com/video/BV1KY411x7Jp?from=search&seid=12675776470220873194&spm_id_from=333.337.0.0
                得到会话密钥的过程,是非对称加密(非对称加密消耗资源大)
                得到会话密钥后,在此之后都使用会话密钥进行交流,是对称加密
                除了双方,没人知道会话密钥(它由客服端的随机数,预主密钥,服务端的随机数共同生成)是什么,因此双方用会话密钥进行沟通

        - 优点
            内容加密，中间无法查看原始内容

        - 缺点
            证书要钱
            https双方加解密，耗费更多服务器资源
            https握手更耗时，降低一定用户访问速度

    22.12.HTTP/HTTPS区别
        HTTP是明文传输，不安全的，HTTPS是加密传输，安全的多
        HTTP标准端口是80，HTTPS标准端口是443
        HTTP不用认证证书免费，HTTPS需要认证证书要钱
        连接方式不同，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次
        HTTP在OSI网络模型中是在应用层，而HTTPS的TLS是在传输层
        HTTP是无状态的，HTTPS是有状态的
X
    对 Cookie 了解多少
        前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢
        HTTP 为此引入了 Cookie。

23.git
    23.1.版本控制
        即版本管理器,方便查看恢复以前的版本
    23.2.与SVN的区别
        SVN是集中式版本控制,版本数据都在服务器上,用户做完提交到服务器
        GIT是分布式版本控制,版本数据被同步到每个用户上,用户做完提交到本地,最后再提交,而且网络坏了也没事,服务器数据丢失也可以在用户里找回来
    23.3.启动
        Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多
        Git CMD：Windows风格的命令行
        Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令
    23.4.Linux命令
        cd 进入文件
        cd... 上一级文件
        pwd 当前目录路径
        clear 清屏
        touch 新建文件
        mkdir 新建文件夹
        rm 删除
    23.5.配置
        配置文件，其实都保存在本地
        查看所有 git config -l
        只看系统 git config --system -l
        设置用户名与邮箱,这是非常重要的，因为每次Git提交都会使用该信息
        git config --global user.name "kuangshen"  #名称
        git config --global user.email 24736743@qq.com   #邮箱
    23.6.git工作原理
        Git本地有三个工作区域：工作目录,暂存区,资源库。
        如果在加上远程的git仓库就可以分为四个工作区域。
        git add/commit/push

        Workspace：工作区，就是你平时存放项目代码的地方
        Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息
        Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本
        Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换
    23.7.git项目搭建
        创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。
        - 本地搭建仓库
            git init 
        - 克隆远程仓库
            将远程服务器上的仓库完全镜像一份至本地
            git clone [url]
    23.8.git的基本操作
        git status [filename]       查看指定文件状态,可能会查看到一些没有被提交的文件,需要以下命令提交
        git add .                   添加所有文件到暂存区
        git commit -m "文件名"      提交暂存区中的内容到本地仓库 -m 提交信息

        忽略文件
            有些文件不需要提交,不如前端项目中的npm_moudles
            *所有的某某 !除了某某 /某某目录下的文件
    23.9.gitee
        注册登录fitee
        (设置本机绑定SSH公钥，实现免密码登录,将生成的文件添加到gitee中即可)
        在gitee创建仓库
        clone到本地
    23.10.git分支
        分支就是多个版本,并行执行时不会冲突
        涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。
        # 列出所有本地分支
        git branch
        # 列出所有远程分支
        git branch -r
        # 新建一个分支，但依然停留在当前分支
        git branch [branch-name]
        # 新建一个分支，并切换到该分支
        git checkout -b [branch]
        如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！
        # 合并指定分支到当前分支
        $ git merge [branch]
        # 删除分支
        $ git branch -d [branch-name]
        master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，
        工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。


24.udp
    UDP        
    TCP 
    [是否连接]
    无连接(面向无连接
    首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。
    并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。)
    面向连接

    [连接对象个数]
    支持一对一，一对多，多对一和多对多交互通信
    只能是一对一通信

    [是否可靠]
    不可靠传输，(不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
    并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。)
    (UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。
    这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景)
    可靠传输，使用流量控制和拥塞控制


    ; [传输方式]
    ; 面向报文
    ; 面向字节流

    [首部开销]
    首部开销小，仅8字节
    首部最小20字节，最大60字节

    适用场景
    适用于实时应用（IP电话、视频会议、直播等）
    适用于要求可靠传输的应用，例如文件传输

    其他知识
    流量控制:
        接收方每次发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，称为接收窗口大小
        发送方收到之后，便会调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，
        发送方就会停止发送数据，防止出现大量丢包情况的发生，并且同时开启一个定时器，
        每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了

    拥塞控制:
        如果发送方迟迟没有收到接收方反馈的ACK，那么发送方就会认为它发送的数据包丢失了，进而会重新传输这个丢失的数据包。
        但是实际情况有可能此时有太多主机正在使用信道资源，导致网络拥塞了，而A发送的数据包被堵在了半路，迟迟没有到达B。
        这个时候A误认为是发生了丢包情况，会重新传输这个数据包,会使网络更加拥塞

        解决方法,控制发送一个数据包的数量,1,2,4,8,...,12,13,14,前期指数增长，到达阈值之后，就以一个一个线性的速度来增长

        当达到最大值MAX之后，我们该怎么办呢
        将阈值调小,一般为MAX/2,继续从1，2，4...增长


25.浏览器渲染
    25.1.过程
        解析HTML生成DOM树。
        解析CSS生成CSSOM规则树。
        从DOM树的根节点开始遍历每个可见节点。找到其适配的CSS样式规则并应用。将DOM树与CSSOM规则树合并在一起生成渲染树。
        渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式,遍历渲染树开始布局，计算每个节点的位置大小信息。
        将渲染树每个节点绘制到屏幕。
    25.2.渲染阻塞
        当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。
        每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，
        而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。

        所以我们应该
        CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
        JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。
    25.3.解释
        DOM树是节点,CSS树是一个对象包含规则
        通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。
        渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。

26.浏览器缓存机制(HTTP 缓存中的强缓存与协商缓存)
    浏览器缓存是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用
    http缓存机制主要在http响应头中设定,就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源,而无需跑到服务器去获取。

    浏览器缓存分为强缓存和协商缓存
    强缓存：通过响应头cache-control的max-age设置时间,在这时间内,浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回,
    协商缓存: 过响应头e-tag,发送请求时,进行缓存新鲜度校验,如果资源过旧,则从响应中获取资源,否则从缓存中获取

27.交换变量
    解构赋值

28.前端模块化
    就是将独立的功能代码封装成一个独立的文件，其他模块需要使用，在进行引用
    28.1.好处
        命名冲突,[复用性,维护性]
    28.2.CommonJS   
        module.exports 导出  require 导入
    28.3.ES6 模块化
    28.4.CommonJS和ES6模块有什么区别
        https://juejin.cn/post/7048139060983889950
        CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
            CommonJS模块加载以后，它的内部变化就影响不到它的值了,值被缓存了,不会改变
            ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值

        CommonJS 模块是运行时加载,ES6 模块是编译时输出接口
            CommonJS 整体加载模块（即加载模块所有方法），生成一个对象，然后再从这个对象上面读取3个方法。
            这种加载称为“运行时加载”，因为只有运行时才能得到这个对象
            ES6 实质是从模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载

29.调试代码
    29.1.console.log 
    29.2.最简单的断点调试，就是在代码中加一句 debugger，然后到浏览器中刷新页面，这时候浏览器就会在 debugger 语句那停止执行。

30.移动端适配
    像素:最小图像单元,分辨率:纵横向上的像素点数,当屏幕分辨率低时，在屏幕上显示的像素少，单个像素尺寸比较大。
    如果手机分辨率翻倍，我们的图像不就要被缩小一倍，我们难道要在每个设备上就出个设计稿，每个设备的分辨不尽相同啊??
    设备独立像素:把2x2个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变
                因此设计稿是640 x 480,但手机分辨率是1600 x 1200
    设备像素比(dpr):物理像素和设备独立像素的比值
    1px边框问题:当我们css里写的1px的时候，由于它是逻辑像素，导致我们的逻辑像素根据这个设备像素比（dpr）去映射到设备上就为2px



    解决适配方法:
        1.使用 css 的媒体查询 @media,分别为不同屏幕尺寸的移动设备编写不同尺寸的 css 属性,代价高,所有元素都要在不同尺寸里重新定义
        2.rem适配,取决于html字体大小,不同的尺寸需要写多个 @media,然后改变html字体大小,导致rem改变
        3.flexible
            将 html 节点的 font-size 设置为页面 clientWidth(布局视口)的 1/10，
            1rem 就等于页面布局视口的 1/10，这就意味着我们后面使用的 rem 都是按照页面比例来计算的
        4.vw vh,宽高的1%
        5.viewport:在用户不进行手动缩放的情况下，可以将页面理想地展示。那么所谓的理想宽度就是浏览器（屏幕）的宽度了
            <meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;">
            他规定了我们的视口宽度为屏幕宽度，初始缩放比例为1，就是初始时候我们的视觉视口就是理想视口


31.es6新方法
    Array.isArray
    arr.flat
    arr.find(回调,数组) 查找数组中满足要求的第一个元素的值
    object.assign

32.css对于不同浏览器适配

33.doctype
    告知浏览器的解析器，用什么类型/规范来解析这个文档
34.seo
35.CSS预处理器
36.es6新增命名let const class import,原有function var
   es6新增数据类型 symbol set map 
                weakset
                (WeakSet与Set类似，也是不重复的值的集合，但WeakSet的成员只能是对象) 
                weakmap
                (WeakMap与Map类似，也是用来生成键值对的集合。但WeakMap只接受对象作为键名)
   四种改颜色的方法 RGB HSL(色相、饱和度、亮度) color:#XXXXXX color:red
   浏览器内核
        IE Trident主要包含在 window操作系统的 IE浏览器中
        firefox GeckoGecko的特点是代码完全公开，因此，其可开发程度很高
        Safari webkit苹果公司自己的内核，包含WebCore排版引擎及JavaScriptCore解析引擎
        chrome Chromium/[Blink]/webkitBlink是开源引擎WebKit中WebCore组件的一个分支

   定时器是setTimeout 不是setTimeInterval this是在匿名函数里的 

37.前端优化
    https://juejin.cn/post/6892994632968306702#heading-11

38.看看word里vue-cli做了哪些配置
    lintOnSave:false,关闭eslint 
    devServer: {
        proxy: {
          '/api': {
            target: 'http://39.98.123.211',
            
          },
        }
    }跨域配置


39.对vue的理解
    MVVM
https://q.shanyue.tech/fe/perf/688.html
https://www.yuque.com/cuggz/interview/hswu8g
https://vue3js.cn/interview/vue/vue.html#%E4%B8%80%E3%80%81%E4%BB%8E%E5%8E%86%E5%8F%B2%E8%AF%B4%E8%B5%B7

40.字符串转数字
    parseFloat() 数字以外的会被省略,若只有字母则是NaN,第一个参数是值,第二个参数是代表几进制
    parseInt()
    Number()

    +""
    String(X)
    X.toString()

41.字符串方法
    charAt
    slice 
    substr(start, [length]) 包括开始 的length长度的字符串
    substring(from, [to]) 包括开始 但不包括结尾

    concat(v1,v2..)
    lastIndexOf/indexOf
    split 
    replace(regexp/substr, replacetext)方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
    toLowerCase()/toUpperCase()
    includes() 方法用于检查字符串是否包含指定的字符串或字符。
    trim()


42.清除浮动
    为什么要清除浮动?
    存在高度塌陷,文字排版问题
    解决:
        clear:XXX 
        在有浮动的父级元素的末尾插入了一个没有内容的块级元素div,并设置clear
        利用.clearfix:after给父元素加一个内容
        overflow（值不为visible）(开启了BFC)

43.DOM操作 
    查询,节点关系,创建插入删除克隆,添加修改移除属性
    鼠标事件对象,offset...

44.BOM与DOM
    DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性,顶级对象是document,由W3C规范
    BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器,顶级对象是window,由各个浏览器厂商规范
    Javascript 由三部分构成，ECMAScript，DOM和BOM

    DOM 是为了操作文档出现的接口，那 BOM 顾名思义其实就是为了控制浏览器的行为而出现的接口
    比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数。所以 BOM 就是为了解决这些事情出现的接口。比如我们要让浏览器跳转到另一个页面，只需要location.href = "http://www.xxxx.com";这个 location 就是 BOM 里的一个对象

    - BOM 比DOM 更大 ，包含着DOM
    window-->document
    window-->location
    window-->navigation
    window-->screen
    window-->history

    - 一些事件
        window.onload 文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS文件等)
        DOMcontentLoaded 仅当DOM加载完成
        window.onresize 调整窗口大小

    - window提供的两个方法
        setTimeout
        setInterval

    - location对象
        window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL。
        因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。

        location.href获取或者设置整个URL
        location.host返回主机(域名)www.itheima.com
        location.port返回端口号如果未写返回空字符串
        location.pathname返回路径
        location.search返回参数
        location.hash返回片段#后面内容常见于链接锚点

        location.assign()跟href一样，可以跳转页面（也称为重定向页面)
        location.replace()替换当前页面，因为不记录历史，所以不能后退页面
        location.reload()重新加载页面，相当于刷新按钮或者f5如果参数为true强制刷新ctrl+f5

    - history对象
        与浏览器历史记录进行交互。
        back()	可以后退功能
        forward()	前进功能
        go(参数)	前进后退功能参数如果是1前进1个页面如果是-1后退1个页面

45.什么是同步/异步
    同步任务：就是任务一个一个执行，如果某个任务执行时间过长，后面的就只能一直等下去
    异步任务：就是进程在执行某个任务时，该任务需要等一段时间才能返回，这时候就把这个任务放到专门处理异步任务的模块，
              然后继续往下执行，不会因为这个任务而阻塞

46.js为什么是单线程
    JavaScript 同时只能执行一个任务
    原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果
    优点:简单
    缺点:只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行

47.进程/线程    
    进程是cpu资源分配的最小单位,每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销,相当于工厂,
    线程是cpu调度的最小单位,一个进程中可以有多个线程,同一类线程共享代码和数据空间,线程切换开销小,相当于工厂的工人
    线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。

48.宏微任务
    为了处理高优先级的任务，和解决单任务执行过长的问题，所以需要将任务划分，所以微任务和宏任务它来了
    有微任务队列，自然就有宏任务队列，任务队列中的每一个任务则都称为宏任务，在当前宏任务执行过程中，
    如果有新的微任务产生，就添加到微任务队列中
    当前宏任务里的微任务全部执行完，才会执行下一个宏任务

49.输出题
        console.log(1)
        new Promise( resolve => {
            resolve(2) // 回调 是微任务
            console.log(3)
        }).then( num => {
            console.log(num)
        })
        console.log(4)
        1 3 4 2

        ------

        setTimeout(function () {
        console.log('setTimeout')
        }, 0)
        new Promise(function (resolve) {
            console.log('promise1')
            for( let i = 0; i < 1000; i++ ) {
                i === 999 && resolve()
            }
            console.log('promise2')
        }).then(function ()  {
            console.log('promise3')
        })
        console.log('script')

        promise1 -> promise2 -> script -> promise3 -> setTimeout

        promise里的内容是同步的
        继续执行promise，打印promise1
        遇到循环，执行，遇到回调 resolve()，上面说了回调属于微任务，放到微任务队列
        继续执行，打印 promise2

        ------------

        async function fun() {
            console.log(1)
            let a = await 2
            console.log(a)
            console.log(3)
        }
        console.log(4)
        fun()
        console.log(5)

        await下面的内容就等于then回调
        4 1 5 2 3

        它等同于

        function fun(){
            return new Promise(() => {
                console.log(1)
                Promise.resolve(2).then( a => {
                    console.log(a)
                    console.log(3)
                })
            })
        }
        console.log(4)
        fun()
        console.log(5)

        -------

        function bar () {
            console.log(2)
        }
        async function fun() {
            console.log(1)
            await bar()
            console.log(3)
        }
        console.log(4)
        fun()
        console.log(5)

        4 1 2 5 3

        为啥？上面例子中 2 都没打印出来，为啥这个就出来了
        因为await的意思就是等，等await后面的执行完。
        所以"await bar()"，是从右向左执行，执行完bar()，然后遇到await，
        返回一个微任务(哪怕这任务里没东西)，放到微任务队列让出主线程。

        --------

        async function async1 ()  {
            console.log('2 async1 start');
            await  async2();这里从右向左执行,并返回一个微任务,加入微任务队列
            console.log('6 async1 end')
        }

        async function  async2 ()  {
            console.log('3 async2')
        }

        console.log('1 script start');

        setTimeout(function ()  {
            console.log('8 setTimeout')
        },  0);加入宏任务队列

        async1();

        new Promise(function (resolve)  {
            console.log('4 promise1');
            resolve()
        }).then(function ()  {
            console.log('7 promise2')
        });这里是一个微任务,加入微任务队列

        console.log('5 script end');1-5都是同步的,不属于宏微任务

50.!深浅拷贝
    - 浅拷贝
        1.
        function clone(target) {
            let cloneTarget = {};
            for (const key in target) {
                cloneTarget[key] = target[key];
            }
            return cloneTarget;
        };
        复制代码创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。

        2.或使用Object.assign()

        3.或{...对象}


    - 深拷贝 
        1.JSON.parse(JSON.stringify())
            这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象
            这种方法虽然可以实现数组或对象深拷贝,但不能处理函数 得到的函数就不再是函数（变为null）

        2.手写

        第一版本
         function clone(target) {
            if (typeof target === 'object') {
                ;如果是对象 则执行深拷贝
                let cloneTarget = Array.isArray(target) ? [] : {}
                ;判断是数组还是对象 创建一个空的
                for (const key in target) {
                    cloneTarget[key] = clone(target[key]);
                }
                ;forin循环遍历 并且递归调用
                return cloneTarget;
            } else {
                ;否则返回
                return target;
            }
        };

        第二版本 考虑循环引用
        function clone(target, map = new Map()) {
            if (typeof target === 'object' && target!==null) {
                let cloneTarget = Array.isArray(target) ? [] : {};
                ;target当前需要拷贝的对象 cloneTarget拷贝的对象



                if (map.get(target)) {
                    return map.get(target);
                };当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，
                ;如果执意去for遍历target,会出现栈溢出
                map.set(target, cloneTarget);
                ;如果没有，将当前对象作为key，克隆对象作为value进行存储
                ;如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。




                for (const key in target) {
                    cloneTarget[key] = clone(target[key], map);注意调用map
                }
                return cloneTarget;
            } else {
                return target;
            }
        };


51.401/403
    401 未经过认证，没有提供身份验证或身份验证失败
    403 被禁止	服务器拒绝响应它。 与401状态码不同，提供身份验证不会改变结果。

52.生命周期

53.响应式原理 
    https://zhuanlan.zhihu.com/p/88648401
    观察者模式(dep,先注册事件,要执行的时候再去触发) + 数据劫持(defineproperty getter setter)


   

        组件初始化的时候，先给每一个Data属性都注册getter，setter，也就是reactive化。
        ;每一个data的属性都会有一个dep对象。当getter调用的时候，去dep里注册函数，setter的时候，就是去通知执行刚刚注册的函数。
        组件初始化的时候，然后再new 一个对应这个组件的Watcher对象，此时watcher会立即调用在这个组件的render函数去生成虚拟DOM。
        在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，dep的注册函数,而将这个组件的Watcher函数注册进sub里

        当data属性发生改变之后，dep执行注册函数,就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。

        也就是一个属性可能注册了多个watcher,每个watcher对应一个组件,改变的时候通知这些watcher修改他们对应的组件

54.diff算法
    Diff算法是一种对比算法。对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，
    只更新这个虚拟节点所对应的真实节点，实现精准地更新真实DOM，进而提高效率。

    1.只比较同一层级
    2.只比较标签名,不同则认为是新的
    3.若标签名相同,key相同,则认为是相同节点

55.render 函数
    和 template 一样，都是用来创建 HTML 模板的。

56.html5 css3
    html5
    语义化标签 
    音视频处理
    canvas  标签只是图形容器，必须使用脚本来绘制图形。
    SVG绘图 SVG是指可伸缩的矢量图形
    localStorage、sessionStorage -- 用于本地离线存储。
    地理位置 window.navigator.geolocation 
    dom查询两种方式
    表单功能增强 input 标签可以输入各种类型从而渲染相应的表单内容
                    <p>邮箱标签: <input type="email"></p>
                    <p>数字标签: <input type="number"></p>
                    <p>滑动条标签: <input type="range"></p>
                    <p>搜索框标签: <input type="search"></p>
                    <p>日期框: <input type="date"></p>
                    <p>星期框: <input type="week"></p>
                    <p>月份框: <input type="month"></p>
                    <p>颜色框: <input type="color"></p>
                    <p>网址框: <input type="url"></p>

    css3
    过渡 过渡需要触发一个事件才会随着时间改变其
    动画 CSS属性动画在不需要触发任何事件的情况下
    新增选择器 如:first-of-type选择某一类的第一个子元素,:nth-child()
    阴影 文字阴影: text-shadow: 2px 2px 2px #000;(水平阴影，垂直阴影，模糊距离，阴影颜色) 盒子阴影: box-shadow: 10px 10px 5px #999
    边框 border-image边框图片,border-radius
    背景 background-clip制定背景绘制（显示）区域 默认情况（从边框开始绘制） background-clip: padding-box;从padding开始绘制 content-box
         background-origin border-box就是把背景图片的坐标原点设置在盒模型border-box区域的左上角
                            padding-box就是把背景图片的坐标原点设置在盒模型padding-box区域的左上角
                            content-box就是把背景图片的坐标原点设置在盒模型content-box区域的左上角
         background-size 制定背景的大小
    颜色 rgba hsla h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”
    渐变 linear-gradient()
        线性渐变的开头，我们可以指定一个渐变的方向
                        to left
                        to right
                        to bottom(默认)
                        to top
                        to top left...(上面的组合)
                        repeating-linear-gradient(to right ,red, yellow 50px);
                        linear-gradient(red 50px,yellow 100px, green 120px, orange 200px); 
    弹性布局
    媒体查询 

57.cdn通过script的src引入
src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，[会暂停其他资源的下载和处理]，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。
href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，[不会停⽌对当前⽂档的处理]。 常用在a、link等标签上。

58.数组去重
    https://juejin.cn/post/6844904031425413128
    - 普通数组去重
        1.双层 for 循环,遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组
        2.相邻元素去重 sort排序 定义新数组 遍历原数组 如果当前元素不等于前一个元素 则push
        3.Array.filter() 加 indexOf
        4.ES6 中的 Set 去重 
        5.Object 键值对 创建空对象,空数组,遍历数组，当 if (!obj[arr[i]])
                则把这个数据push进空数组,并设置obj[arr[i]] = 1 将数组中的值设为对象的属性，并给该属性赋初始值1
                若不满足,每出现一次，则对应的属性值增加1，这样，属性值对应的就是该元素出现的次数了
                        

    对象怎么去重
    方法一：双层for循环
    两两比较，如果后一个对象的id值和前一个对象的id值相等，就把后面的对象删除
    方法二：indexOf()
    定义一个数组存储id的值,然后逐个比较,把id值重复的对象删除即可

59.css选择器和优先级
    选择器
    主要复习以下伪类伪元素
        伪类
            :first-child 选取当前选择器下的第一个元素
            :last-child 选取当前选择器下的最后一个元素
            :nth-child(an+b) 选取指定位置的元素,参数支持an+b的形势.比如 li:nth(2n+1),
            :empty 选取没有子元素的元素
        伪元素 伪元素选择器并不是真实的DOM元素,所以称之伪元素
            ::first-line 为元素的第一行使用样式
            ::first-letter 为某个元素的首字母或第一个文字使用样式
            ::before 在某个元素之前插入内容
            ::after 在某个元素之后插入内容

    优先级
        有四个等级1000,100,10,1,数字使用的是使用的是256进制
        第一优先级：!important会覆盖页面内任何位置的元素样式
        1.内联样式，权值为1000
        2.ID选择器，权值为0100
        3.类、伪类、属性选择器，权值为0010
        4.标签、伪元素选择器，如div::first-line，权值为0001
        5.通配符、关系选择器，权值为0000
        6.继承的样式没有权值
        优先比较高位,相同则使用靠下的样式

60.哈希表
    在存储元素的时候,元素和他的存储地址间建立一个关系函数,在查找的时候可以通过这个函数快速找到元素的地址
    总的来说，哈希表就是一个具备映射关系的表，你可以通过映射关系由键找到值

    - 构造方法
        数字分析法,取其中某些数字
        平方取中,平方后取中间位的数字
        除留余数,有11个数,设表长13,数字%13,余数就是位置

    - 处理冲突的方法
        开放地址法
            线性探测:找下一个空位
            二次探测:1 -1 4 -4 9 -9
            伪随机:有一个伪随机序列,2,5,9,如果9%11...9发现冲突,那么(9+2)%11再试试
        再哈希法
            构造多个哈希函数
        链地址法
            创建一个数组,加入元素时,在这个点去创建一个链表,冲突时,继续放在在这个链表后面

    - 性能分析
        总计算次数/元素个数

61.排序算法
    - 稳定性
        排序后,两个相同的数据,它的位置会不会发生变化

    - 插入类排序
        1.直接插入
            从左边第一个开始,左边排好序,右边没有
            将右边第一个插入到左边
            代码:开一个循环遍历右边的数,从右边的第一个数开始,从左边的最右边开始循环,如果数字小于当前数,右移
        2.折半插入
            查找的时候,会使用二分法
        3.希尔排序
            将排序分为若干个子序列,一般是取间隔多少,然后对几个子序列分别进行插入排序
            然后减小间隔,同上,最后间隔减小到1,也就是原序列,对其进行排序

        其中,直接插入折半插入是稳定的,因为他们的比较条件是flag<arr[j]
        而希尔算法不稳定,因为分成了几个序列各自排序,不知道对方情况

    - 交换类排序
        1.冒泡排序
            每一趟循环,比较左右两个数字大小,调整顺序,把最大的移动到序列最右
            优化:在for设置一个条件change,初始值未false,如果改变了则设置未true
                因此,若排序未改变,则说明已完成,不用再执行后面的for
        2.快速排序
            提取一个关键字(一般是第一个数),以它为中间数,设置左右两个指针
            这个时候左指针位置为空,移动右指针,如果右指针数小于关键字,则把他移动到左指针位置
            此时右指针空,移动左指针,找到比关键字大的数字,把它移动到右指针
            重复,直到两个指针相遇,把关键字放进去,完成一趟排序,左边的数全比关键字小,右边的大

            代码:三个参数,数组,左指针,右指针
                提取基准,while(左<右),{
                    while(左<右 且 右指针找到比基准大的数)
                    移动右指针
                    if(左<右 证明右指针找到了比基准小的数 且不是因为左右指针重合)
                    把这个数放到左指针,左指针++

                    同上
                }
                把基数保存到指针位置,返回指针位置

                对于完整的快速排序,三个参数,数组,左指针,右指针
                当左<右,执行一次一趟排序并记录基数,然后对左边和右边递归排序

        其中,冒泡排序稳定,快速排序不稳

    - 选择类排序
        1.简单选择排序
            两个指针,左指针指向最左,右指针指向左指针
            右指针循环遍历,找到最小的,和左指针元素交换
            左++,右指向左
        2.堆排序
            建立初堆,把数据用二叉树的形式表现出来,让后从最后一个叶子节点开始,自底向上,让所有的子堆的堆顶变为最大,最后堆顶就选出最大的元素
            调整堆,堆顶和堆尾交换,堆尾不参加(堆尾就是最大的,不用再排序了),顶部移除,下层大的数字向上移动,选出最大的数字
                    然后再重复一遍,可以选出第二大的数字到堆尾

            其中,两者均不稳定
        
    - 归并排序
        把序列拆成2个一组,这2个进行排序,形成有序队列
        让后让2个有序队列,进行排序,形成一个有四个数据的有序队列
        最终合成一个有序队列

62.DIFF算法 
    https://juejin.cn/post/6994959998283907102#heading-2
    - 什么是diff 
        Diff算法是一种对比算法。对比两者是旧虚拟DOM和新虚拟DOM，
        对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点

    - 什么是vnode
        h函数会通过算法返回一个vnode节点，而vnode节点是保存了6个属性的节点,
        选择器,事件,孩子/文本(二选一),真实dom(vnode对应的真实dom元素),key
        vnode可以理解成节点描述对象，他描述了应该怎样去创建真实的DOM节点
        vue使用虚拟DOM中主要做了两件事，一个是创建了VNode来模拟DOM树，


--------------------diff过程----------------------


    当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，
    订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图。


    sameVnode:
        用于比较两个节点是否为同一类型
        主要是比较key,标签,是否都为注释节点,否都定义了data,当标签为input时，type必须是否相同


    patch函数执行过程:
        ;patch函数有两个形参,第一个接收一个vnode或dom节点(代表旧节点),第二个接收vnode(代表新节点)
        ;当第一个参数是dom元素,那会创建空的vnode
        然后比较新旧vnode,根据sameVnode方法比较,看他们是否相同
        相同,则执行patchVnode函数,进行深层次的比较
        若不相同,则根据第二个参数(新vnode)生成dom,代替老的dom
    patch函数使用场景:
        在组件首次渲染时执行(传入容器和节点),将vnode渲染到容器(容器是一个dom,patch发现是dom后会生成一个空的vnode)里
        在页面更新时,再次执行patch函数,让新vnode替换老的


    patchVnode:
        当在patch函数中,比较新旧dom时发现标签和key相同时执行,进行深层次的比较
        注意,新旧vnode的标签key相同,代表节点未更新,但是新旧vnode不一定相同,新vnode可能有些属性是没有的,需要操作
    patchVnode执行过程:
        把老vnode上关联的dom元素赋值给新vnode,即获取真实dom节点
        判断新Vnode和老Vnode是否相同，如果是，那么直接return
        如果他们都有文本节点并且不相等，那么将真实dom节点的文本节点设置为新Vnode的文本节点。
        如果老Vnode有子节点而新Vnode没有，则删除真实dom的子节点
        如果老Vnode没有子节点而新Vnode有，则将新Vnode的子节点真实化之后添加到真实dom
        如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要


    updateChildren:
        当patchVnode,新旧vnode都有子节点时,调用
    updateChildren执行过程:
        首尾指针法,给新旧vnode的chilren的首尾定义指针

        每次做比较的时候,有四种情况
        老的首指针和新首尾指针比较,老的尾指针和新的首尾指针比较
        当发现有相同节点的时候,即我们发现了同一个节点在新旧中的位置
        把真实dom里的节点依据新vnode的子节点的位置更新(真实dom的节点是老的,现在要把它变成新的)
        移动相同的那两个指针,首指针向尾部移动,尾指针向首部移动
        如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -> index 表
        然后用新 vnode 的 key 去找出在旧节点中可以复用的位置。即如果新旧节点中,key相同且index相同,则代表未更新,真实dom可以复用这个节点

        然后继续比较,直到
        当老尾指针跑到首指针前面了,则代表老vnode的子节点遍历完了,说明新子节点比老子节点多,将多出来的节点，插入到真实DOM上对应的位置上
        当新尾指针跑到首指针前面了,说明新子节点比老子节点少,然后老的子节点会有多出的节点，结果会在真实DOM里进行删除这些旧节点。







63.怎么判断两个json对象是否相等
    - 题外话
        将一个对象直接保存到localstorage,会错误[object object]
        需要先json.stringfy转化为字符串,再存

    - 简单方法
        模糊对比：将两个json数据（JSON.stringify）转成字符串，进行对比。

    - 精确方法


64.数据存储时,堆和栈的区别
    https://juejin.cn/post/6844903873992196110
    JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。
    其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

    栈被称为是一种后入先出
    堆是一种经过排序的树形数据结构，每个结点都有一个值。 通常我们所说的堆的数据结构，是指二叉堆。 
    堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。


    栈内存主要用于存储各种基本类型的变量,而堆内存主要负责像Object这种变量类型的储存。
    栈内存中的变量一般都是有已知大小或者范围上限的，算作是一种简单储存。
    而堆内存存储的对象类型数据对于大小这方面，一般是未知的。   
    引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 
    这也是为什么Null作为一个object类型的变量却储存在栈内存中的原因。

    读取栈底内存时，需要先清除栈顶的内存吗？
    读取和清除是两个不同的概念，读取是基于词法环境的，清除值得是垃圾回收，这里的后进先出指的是垃圾回收

    为了使程序运行时占用的内存最小，通常要实现垃圾回收机制。

    当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈存里
    ，[[[[[[[[随着方法的执行结束，这个方法的栈存也将自然销毁了]]]]]]]]。因此，所有在方法中定义的变量都是放在栈内存中的；

    当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本开销较大）
    这个运行时数据区就是堆内存。[[[[[[[堆内存中的对象不会随方法的结束而销毁]]]]]]]，即使方法结束后，
    这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，
    [[[[[[[只有当一个对象没有任何引用变量引用它时]]]]]]]，系统的垃圾回收机制才会在核实的时候回收它。

65.java和js区别
    - JavaScript 是动态类型语言；而 Java 是静态类型语言。
        动态类型语言是指在运行期间才去做数据类型检查的语言，把类型绑定延后到了运行阶段。
        静态类型语言的数据类型是在编译期间确定的，或者说运行之前确定的，编写代码的时候要明确确定变量的数据类型。
        在 JavaScript 中，可以更改一个变量的数据类型：
        但在 Java 中，无法更改一个变量的数据类型，如果强制操作，会报错。
    - JS处理网页的事件,ajax,JAVA处理后端数据
    - 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。
        编译型语言是代码在[运行前]编译器将人类可以理解的语言（编程语言）转换成机器可以理解的语言。
        解释型语言也是人类可以理解的语言（编程语言），也需要转换成机器可以理解的语言才能执行，但是是在[运行时]转换的。

66.Object.freeze(obj)
    冻结一个对象或者一个数组,冻结的是对象本身
	冻结后的对象或者数组不能被修改
	不能添加新的属性  不能删除已有属性   不能修改已有属性的值
	返回值是被冻结的对象本身，与被冻结的源对象完全一致，也被冻结

67.input的type
    	原有的:button/radio(相同name选中其中一个)/checkbox/password/text(默认值)
        HTML5新增的
                    <p>邮箱标签: <input type="email"></p>
                    <p>数字标签: <input type="number"></p>
                    <p>滑动条标签: <input type="range"></p>
                    <p>搜索框标签: <input type="search"></p>
                    <p>日期框: <input type="date"></p>
                    <p>星期框: <input type="week"></p>
                    <p>月份框: <input type="month"></p>
                    <p>颜色框: <input type="color"></p>
                    <p>网址框: <input type="url"></p>

68.长列表渲染
    虚拟列表的实现，实际上就是在首屏加载的时候，只加载可视区域内需要的列表项
    当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除

    infinite-list-container 为可视区域的容器
    infinite-list-phantom 为容器内的占位，高度为总列表高度，用于形成滚动条
    infinite-list 为列表项的渲染区域
    <div class="infinite-list-container">
        <div class="infinite-list-phantom"></div>
        <div class="infinite-list">
        <!-- item-1 -->
        <!-- item-2 -->
        <!-- ...... -->
        <!-- item-n -->
        </div>
    </div>
    注意infinite-list-phantom与infinite-list是兄弟,通过translate3d向下移动偏移量
    我们才能看到渲染的列表,否则渲染列表就在最下面了??????如果没有偏移量渲染列表在哪???



    给容器绑定一个@scroll事件,触发时会计算以下属性

    根据滚动距离和 单个列表数据 高度，计算出当前需要展示的列表的 起始索引
    根据 起始索引 和 可视区高度，计算出当前需要展示的列表的 末尾索引
    根据 起始索引 和 末尾索引 截取相应的列表数据，赋值给可视区列表，并渲染在页面上
    根据滚动距离和 单个列表数据 高度，计算出可视区列表的偏移距离 startOffset，并设置在列表上
    (我们通过偏移量设置style,将渲染区域向下移动)


    偏移量startOffset = scrollTop - (scrollTop % itemSize);
    列表总高度listHeight = listData.length * itemSize
    可显示的列表项数visibleCount = Math.ceil(screenHeight / itemSize)
    数据的起始索引startIndex = Math.floor(scrollTop / itemSize)
    数据的结束索引endIndex = startIndex + visibleCount
    列表显示数据为visibleData = listData.slice(startIndex,endIndex)



    代码中:写一个容器,装着通过vfor生成列表,但是这个vfor数据来源的数组,只装需要渲染的列表,而不是全部
        这道题的数据通过计算属性得到,比如 visibleData
        return this.listData.slice(this.start, Math.min(this.end,this.listData.length));
        根据计算得到的起始末尾值,通过slice截取所有数据的数组,生成visibleData

    - 如果数据高度不相等怎么办呢
        对组件属性itemSize进行扩展，支持传递类型为数字、数组、函数
        可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, ...]
        或者写一个方法,传入数据index,用于获取数据高度

        但这样,仍然是预先知道数据的高度,如果不知道呢?


    - 偏移量怎么使用的?
        配置一个style,通过transform的traslate属性向下移动渲染容器,距离为偏移量

    - 还可以在上下方多弄几条数据,用于过渡

    - 监听事件
        使用@scroll给可视区容器绑定

    - 
    比如说，列表第0项，高度100px，你现在滚动条滚动了50px，期望的效果必然是第0项，一半在屏幕外，一半在屏幕内，
    此时是没有偏移量的，完全由滚动条来控制页面显示内容。此时又发生了滚动，滚动到了100px，此时我们期望的的：
    可视区域已经没有第0项了，变成第1项。由于我们是虚拟列表，所以第0项的dom发生了修改变成了第1项的dom
    ，第一项的dom变成了第2项dom，如果没有偏移量，可视区域的第一条内容就变成了第2项，所以我们需要修改偏移量，
    让列表像下偏移100px，将第1项的dom显示出来

69.上一题中要用到的数据
    scorllTop被卷去的高度
    document.body.clientHeight //获取可视区高度
    元素.getBoundingClientRect() // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置

70.说一下JSON.stringify有什么缺点？
    JSON.stringify()  方法将一个 JavaScript 对象(包括数组)或值转换为 JSON 字符串

        undefined、任意的函数以及symbol值，出现在非数组对象的属性值中时在序列化过程中会被忽略
        undefined、任意的函数以及symbol值出现在数组中时会被转换成 null。
        undefined、任意的函数以及symbol值被单独转换时，会返回 undefined

71.垃圾回收
    https://juejin.cn/post/6844903833387155464

    1.垃圾回收
        - 为什么要垃圾回收
            JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。
            只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，
            否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

        - 引用法
            就是判断一个对象的引用数，引用数为0就回收，引用数大于0就不回收。
            缺点:两个对象互相引用,引用数都是1,不会回收,造成内存泄漏
                 首先它需要一个计数器，而此计数器需要占很大的位置

        - 标记法
            将可达的对象标记起来，不可达的对象当成垃圾回收。
            从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，
            说明该子节点的引用对象可达，并为其进行标记。
            那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用
            就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。

            缺点: 就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），
            并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题

            而 标记整理（Mark-Compact）算法 就可以有效地解决
            记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存

    2.JS内存管理
        1、分配给使用者所需的内存
        2、使用者拿到这些内存，并使用内存
        3、使用者不需要这些内存了，释放并归还给系统

        由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的
        由于堆内存所存大小不固定，系统无法自动释放回收，所以需要JS引擎来手动释放这些内存



72.内存泄漏
    概念:申请的内存没有及时回收掉，被泄漏了

    1.意外的全局变量
        function foo(arg) {
            bar = "this is a hidden global variable";
        }
        bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。
    2.被遗忘的计时器或回调函数
        setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期
        所以当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的
    3.闭包  
        使用完函数后，该函数所申请的内存都会被回收了
        但当函数内再返回一个函数时，由于返回的函数持有外部函数的词法环境，
        而返回的函数又被其他生命周期东西所持有，导致外部函数虽然执行完了，但内存却无法被回收
    4.遗漏的 DOM 元素
        DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了
        但如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定了
        记得移除时，两个地方都需要去清理才能正常回收它

73.VUE3的响应式原理

74.项目部署

75.遍历对象
    Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组
    Object.values() 返回属性值
    for in 

76.for of/in 
    遍历数组时候
    for in遍历的是数组的索引（index） 但是会存在一些问题 index索引为字符串型数字，不能直接进行几何运算 使用for in会遍历数组所有的可枚举属性，包括原型
    for of遍历的是数组元素值（value） 而且for of遍历的只是数组内的元素，不包括原型属性和索引

    遍历对象的时候
    可以用for in
    for of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象（iterator）的集合，但是不能遍历对象，因为没有迭代器对象，但如果想遍历对象的属性
    for of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值

77.Cookie
    HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，
    它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器
    ，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

78.再看看bfc / mapset / hash/history / 隐式转换 / 数据结构
    